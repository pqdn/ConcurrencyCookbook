# Глава 3 Утилиты для синхронизации потоков
## Введение
В этой главе вы узнаете как использовать высокоуровневые механизмы синхронизации многопоточного кода. Этот высокоуровневый механизм преставлен следующими классами:
* Semaphore - это счётчик, который управляет доступом к общему ресурсу. Этот механизм один из основных многопоточного программирования и представлен во многих языках программирования.
* CountDownLatch - реализация механизма ожидания завершения различных операций. 
* CyclicBarrier - механизм синхронизации множества потоков при помощи общей точки
* Phaser - механиз для для запуска параллельных задач, разделенных по фазам. Все нити должны завержить текую фазу, чтобы они могли преступить к выполнению следующей фазы.
* Exchanger - точка обмена данными между потоками.
* CompletableFuture - механизм, где одна или несколько задач могут ожидать завершение другой задачи, запущенной асинхронным способом.

Семафор основной механизм синхронизации, который вы можете использовать для защиты любых критических секций. Другие механизмы используются, как правило, для специфических задач. Выбирайте способ синхронизации, который подходит вашему приложению и данной проблеме.

В этой главе представлены семь рецептов, которые покажут вам, как использовать описанные выше механизмы.

## Многопоточное управление доступом к одной (или нескольким) копии ресурса
В этом рецепте, вы узнаете, как использовать семафор, представленный в языке java. 
Семафор это счётчик который защищает доступ к общему ресурсу.

Когда поток захочет получить доступ к общему ресурсу, он должен получить (acquire) семафор.
Если внутренний счётчик семафора больше нуля, семафор делает дикримент счётчика и разрешает доступ к общему ресурсу.
Когда значение счётчика больше нуля, означает, что есть свободные ресурсы, 
которые могут быть использованы, следовательно поток может получить доступ и использовать этот ресурс.

Если значение внутреннего счетчика равно нулю, семафор усыпляет текущий поток, до тех пор, 
пока значение счетчика не станет больше нуля.
Когда значение счётчика равно нулю, означает, что все общие ресурсы используются другими потоками,
и для того, чтобы воспользоваться ими текущий поток должен уснуть, пока ресурс не освободится. 

Когда поток завершает использование общего ресурса, он должен освободить (release) семафор, 
чтобы другие потоки могли получить доступ к общему ресурсу. 
Эта операция увеличит значение внутреннего счетчика семафора.  

В этом рецепте, вы узнаете как использовать класс Semaphore для защиты одного и более ресурсов. 

### Пример - печать документов
12 потоков попробуют напечатать свой документ, используя очередь,
очередь обладает лишь тремя принтерами для печати

```java
public class PrintQueue {
    private final Semaphore semaphore;
    private final boolean freePrinters[];
    private final Lock lockPrinters;

    public PrintQueue() {
        semaphore = new Semaphore(3);
        freePrinters = new boolean[3];
        for (int i = 0; i < 3; i++) {
            freePrinters[i] = true;
        }
        lockPrinters = new ReentrantLock();
    }

    public void printJob(Object document) {
        try {
            semaphore.acquire();
            int assignedPrinter = getPrinter();
            long duration = (long) (Math.random() * 10);
            System.out.printf("%s - %s: chapter3.lesson1.PrintQueue: Printing a chapter3.lesson1.Job in Printer %d during %d seconds\n",
                    new Date(), Thread.currentThread().getName(), assignedPrinter, duration);
            TimeUnit.SECONDS.sleep(duration);
            freePrinters[assignedPrinter] = true;
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            semaphore.release();
        }
    }

    private int getPrinter() {
        int ret = -1;
        try {
            lockPrinters.lock();
            for (int i = 0; i < freePrinters.length; i++) {
                if (freePrinters[i]) {
                    ret = i;
                    freePrinters[i] = false;
                    break;
                }
            }
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            lockPrinters.unlock();
        }
        return ret;
    }
}
```

```java
public class Job implements Runnable {
    private PrintQueue printQueue;

    public Job(PrintQueue printQueue) {
        this.printQueue = printQueue;
    }

    public void run() {
        System.out.printf("%s: Going to print a job\n", Thread.currentThread().getName());
        printQueue.printJob(new Object());
        System.out.printf("%s: The document has been printed\n", Thread.currentThread().getName());
    }
}
```

```java
public class Main {
    public static void main(String[] args) {
        PrintQueue printQueue = new PrintQueue();
        Thread[] threads = new Thread[12];

        for (int i = 0; i < threads.length; i++) {
            threads[i] = new Thread(new Job(printQueue), "Thread" + i);
        }

        for (int i = 0; i < threads.length; i++) {
            threads[i].start();
        }
    }
}
```

### Как это работает?
Ключевая часть примера это метод printJob() класса PrintQueue.
Этот метод показывает три шага, которым вы должны следовать когда будете использовать семафор:
* Первое, вы должны овладеть семафором, при помощи метода acquire()
* Затем, вы должны сделать необходимые операции с этими общими ресурсами
* В конце, освободить семафор, используя метод release()

Другое важное место этого примера - конструктор класса PrintQueue и
инициализация экземпляра семафора. Вы должны проинициализировать семафор числом 3,
для того, чтобы созданный семафор мог защищать дость к трем ресурсам. Первые три потока
которые вызовут метод acquire() смогут получить доступ к критической секции. остальные потоки
будут заблокированы. Когда поток закончит работу с критической секцией и вызовит метод 
release() семафора, другой поток сможет завладеть этим семафором.

### Что ещё следует знать?

The Semaphore class has three additional versions of the acquire() method:
acquireUninterruptibly(): The acquire() method, when the internal
counter of the semaphore is 0, blocks the thread until the semaphore is released.
During this period, the thread may be interrupted; if this happens, the method
will throw an InterruptedException exception. This version of the acquire
operation ignores the interruption of the thread and doesn't throw any
exceptions.
tryAcquire(): This method tries to acquire the semaphore. If it can, it returns
the true value. But if it can't, it returns false instead of being blocked and waits
for the release of the semaphore. It's your responsibility to take correct action
based on the return value.
tryAcquire(long timeout, TimeUnit unit): This method is equivalent to
the previous one, but it waits for the semaphore for the period of time specified in
the parameters. If the period of time ends and the method hasn't acquired the
semaphore, it will return false.
The acquire(), acquireUninterruptibly(), tryAcquire(), and release() methods
have an additional version, which has an int parameter. This parameter represents the
number of permits the thread that uses them wants to acquire or release, in other words, the
number of units that this thread wants to delete or add to the internal counter of the
semaphore.


